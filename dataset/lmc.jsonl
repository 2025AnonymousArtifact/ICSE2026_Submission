{"content":"[RM-001] In the no-fail state, a mis-compare, which shall be characterized by one branch differing with the other two branches by a unique trip level that lasts for more than the persistence limit, shall be reported to failure management as a failure.","plantuml":"start\n\n:In no-fail state;\nif(One branch differing with the other two branches by a unique trip level?) then(yes)\n if(Last for more than persistence limit?) then(yes)\n :It is mis-compare;\n :Reported it to failure management as a failure;\n else(no)\n endif\nelse(no)\nendif\n\nstop"}
{"content":"[RM-002] In the no-fail state, the mid-value shall be the selected value.  Note: a first failure in progress will not affect the method for determining the selected value.","plantuml":"start\n\n:In no-fail state;\n:Mid-value be selected value;\n\nif(A first failure in progress?) then(yes)\n:Not affect method for determining selected value;\nelse(no)\nendif\n\nstop"}
{"content":"[RM-003] In the single fail state, a good channel average of the remaining two good branches shall be used to determine the selected value.","plantuml":"start\n\n:In single fail state;\n:A good channel average of the remaining two good branches;\n:Determine selected value;\n\nstop"}
{"content":"[RM-004] If a second failure is in progress, the selected value shall remain unchanged from the previous selected value.","plantuml":"start\n\nif(A second failure in progress?) then(yes)\n:Selected value remain unchanged;\nelse(no)\nendif\n\nstop"}
{"content":"1.\tExceeding sensor limits shall latch an autopilot pullup when the pilot is not in control (not standby) and the system is supported without failures (not apfail).","plantuml":"start\n\nif(Pilot is not in control (not standby)?) then(yes)\n if(System is supported without failures (not apfail)?) then(yes)\n :Exceeding sensor limits latch an autopilot pullup;\n else(no)\n endif\nelse(no)\nendif\n\nstop"}
{"content":"2.\tThe autopilot shall change states from TRANSITION to STANDBY when the pilot is in control (standby).","plantuml":"start\n\nif(Pilot is in control (standby)?) then(yes)\n:Autopilot change states from TRANSITION to STANDBY;\nelse(no)\nendif\n\nstop"}
{"content":"3.\tThe autopilot shall change states from TRANSITION to NOMINAL when the system is supported and sensor data is good.","plantuml":"start\n\nif(System is supported?) then(yes)\n if(Sensor data is good?) then(yes)\n :Autopilot change states from TRANSITION to NOMINAL;\n else(no)endif\n else(no)\nendif\n\nstop"}
{"content":"4.\tThe autopilot shall change states from NOMINAL to MANEUVER when the sensor data is not good.","plantuml":"start\n\nif(Sensor data is good?) then(no)\n:Autopilot change states from NOMINAL to MANEUVER;\nelse(yes)\nendif\n\nstop"}
{"content":"5.\tThe autopilot shall change states from NOMINAL to STANDBY when the pilot is in control (standby).","plantuml":"start\n\nif(Pilot is in control (standby)?) then(yes)\n:Autopilot change states from NOMINAL to STANDBY;\nelse(no)\nendif\n\nstop"}
{"content":"6.\tThe autopilot shall change states from MANEUVER to STANDBY when the pilot is in control (standby) and sensor data is good.","plantuml":"start\n\nif(Pilot is in control (standby)?) then(yes)\n if(Sensor data is good?) then(yes)\n :Autopilot change states from MANEUVER to STANDBY;\n else(no)\n endif\nelse(no)\nendif\n\nstop"}
{"content":"7.\tThe autopilot shall change states from PULLUP to TRANSITION when the system is supported and sensor data is good.","plantuml":"start\n\nif(System is supported?) then(yes)\n if(Sensor data is good?) then(yes)\n :Autopilot change states from PULLUP to TRANSITION;\n else(no)\n endif\nelse(no)\nendif\n\nstop"}
{"content":"8.\tThe autopilot shall change states from STANDBY to TRANSITION when the pilot is not in control (not standby).","plantuml":"start\n\nif(Pilot is not in control (not standby)?) then(yes)\n:Autopilot change states from STANDBY to TRANSITION;\nelse(no)\nendif\n\nstop"}
{"content":"9.\tThe autopilot shall change states from STANDBY to MANEUVER when a failure occurs (apfail).","plantuml":"start\n\nif(A failure occurs (apfail)?) then(yes)\n:Autopilot change states from STANDBY to MANEUVER;\nelse(no)\nendif\n\nstop"}
{"content":"10.\tThe sensor shall change states from NOMINAL to FAULT when limits are exceeded.","plantuml":"start\n\nif(Limits are exceeded?) then(yes)\n:Sensor change states from NOMINAL to FAULT;\nelse(no)\nendif\n\nstop"}
{"content":"11.\tThe sensor shall change states from NOMINAL to TRANSITION when the autopilot is not requesting support (not request).","plantuml":"start\n\nif(Autopilot is not requesting support (not request)?) then(yes)\n:Sensor change states from NOMINAL to TRANSITION;\nelse(no)\nendif\n\nstop"}
{"content":"12.\tThe sensor shall change states from FAULT to TRANSITION when the autopilot is not requesting support (not request) and limits are not exceeded (not limits).","plantuml":"start\n\nif(Autopilot is not requesting support (not request)?) then(yes)\n if(Limits are not exceeded (not limits)?) then(yes)\n :Sensor change states from FAULT to TRANSITION;\n else(no)\n endif\nelse(no)\nendif\n\nstop"}
{"content":"13.\tThe sensor shall change states from TRANSITION to NOMINAL when the autopilot is requesting support (request) and the autopilot reports the correct active mode (mode).","plantuml":"start\n\nif(Autopilot is requesting support (request)?) then(yes)\n if(Autopilot reports the correct active mode (mode)?) then(yes)\n :Sensor change states from TRANSITION to NOMINAL;\n else(no)\n endif\nelse(no)\nendif\n\nstop"}
{"content":"1.\tThe Inner Loop Roll Regulator Shall not command angular roll accelerations greater than the capability of the system (50 deg/sec2) for durations exceeding 100 frames (1 second @ 100 hz).","plantuml":"start\n\n:In Inner Loop Roll Regulator;\nif(Durations > 100 frames?) then(yes)\n:Command angular roll accelerations <= 50 deg/sec2;\nelse(no)\nendif\n\nstop"}
{"content":"2.\tThe Inner Loop Pitch Regulator Shall not command angular pitch accelerations greater than the capability of the system (50 deg/sec2) for durations exceeding 100 frames (1 second @ 100 hz).","plantuml":"start\n\n:In Inner Loop Pitch Regulator;\nif(Durations > 100 frames?) then(yes)\n:Command angular pitch accelerations <= 50 deg/sec2;\nelse(no)\nendif\n\nstop"}
{"content":"3.\tThe Inner Loop Yaw Regulator Shall not command angular yaw accelerations greater than the capability of the system (50 deg/sec2) for durations exceeding 100 frames (1 second @ 100 hz).","plantuml":"start\n\n:In Inner Loop Yaw Regulator;\nif(Durations > 100 frames?) then(yes)\n:Command angular yaw accelerations <= 50 deg/sec2;\nelse(no)\nendif\n\nstop"}
{"content":"4.\tThe Inner Loop Airspeed Regulator Shall not command translational axial accelerations greater than the capability of the system (32 ft/sec2) for durations exceeding 100 frames (1 second @ 100 hz).","plantuml":"start\n\n:In Inner Loop Airspeed Regulator;\nif(Durations > 100 frames?) then(yes)\n:Command translational axial accelerations <= 32 ft/sec2;\nelse(no)\nendif\n\nstop"}
{"content":"5.\tThe Inner Loop Height Regulator Shall not command translational height accelerations greater than the capability of the system (32 ft/sec2) for durations exceeding 100 frames (1 second @ 100 hz).","plantuml":"start\n\n:In Inner Loop Height Regulator;\nif(Durations > 100 frames?) then(yes)\n:Command translational height accelerations <= 32 ft/sec2;\nelse(no)\nendif\n\nstop"}
{"content":"6.\tThe Inner Loop Roll Regulator Shall not command transient changes in angular roll acceleration greater than 50 deg/sec2/sec.","plantuml":"start\n\n:In Inner Loop Roll Regulator;\n:Command transient changes in angular roll acceleration <= 50 deg/sec2/sec;\n\nstop"}
{"content":"7.\tThe Inner Loop Pitch Regulator Shall not command transient changes in angular pitch acceleration greater than 50 deg/sec2/sec.","plantuml":"start\n\n:In Inner Loop Pitch Regulator;\n:Command transient changes in angular pitch acceleration <= 50 deg/sec2/sec;\n\nstop"}
{"content":"8.\tThe Inner Loop Yaw Regulator Shall not command transient changes in angular yaw acceleration greater than 50 deg/sec2/sec.","plantuml":"start\n\n:In Inner Loop Yaw Regulator;\n:Command transient changes in angular yaw acceleration <= 50 deg/sec2/sec;\n\nstop"}
{"content":"9.\tThe Inner Loop Airspeed Regulator Shall not command transient changes in translational axial acceleration greater than 32 ft/sec2/sec.","plantuml":"start\n\n:In Inner  Loop Airspeed Regulator;\n:Command transient changes in translational axial acceleration <= 32 ft/sec2/sec;\n\nstop"}
{"content":"10.\tThe Inner Loop Height Regulator Shall not command transient changes in translational height acceleration greater than 32 ft/sec2/sec.","plantuml":"start\n\n:In Inner Loop Height Regulator;\n:Command transient changes in translational height acceleration <= 32 ft/sec2/sec;\n\nstop"}
{"content":"1.\tNLGuidance shall always maintain the target on the port-side of the vehicle.","plantuml":"start\n\n:In NLGuidance;\n:Maintain target on vehicle port-side;\n\nstop"}
{"content":"2.\tNLGuidance shall compute the inertial position vector for aim point 1, defining the location at Standoff 1 with an offset from the target position, and oriented on a vector perpendicular to the tangent relative position vector from the vehicle to the corresponding aim point.","plantuml":"start\n\n:In NLGuidance;\nif(Vector define location at Standoff 1 with offset from target position?) then(yes)\n if(It oriented on vector perpendicular to tangent relative position vector from vehicle to aim point?) then (yes)\n  :It is inertial position vector for aim point 1;\n  :Compute the vector;\n else(no)\n endif\nelse(no)\nendif\n\nstop"}
{"content":"3.\tNLGuidance shall compute the inertial position vector for aim point 2, defining the location at Standoff 2 with an offset from the target position, and oriented on a vector perpendicular to the tangent relative position vector from the vehicle to the corresponding aim point.","plantuml":"start\n\n:In NLGuidance;\nif(Vector define location at Standoff 2 with offset from target position?) then(yes)\n if(It oriented on vector perpendicular to tangent relative position vector from vehicle to aim point?) then (yes)\n  :It is inertial position vector for aim point 2;\n  :Compute the vector;\n else(no)\n endif\nelse(no)\nendif\n\nstop"}
{"content":"4.\tNLGuidance shall always select an inertial position vector of aim point #1 or #2 which shall result in a counter clockwise loiter for the UAV.  For example, the picture above with vehicle position, UAV, would return Tangent Aim Point #2.","plantuml":"start\n\n:In NLGuidance;\n:Select inertial position vector of aim point #1 or #2;\n:Counter clockwise loiter for UAV;\nif(As the picture above?) then(yes)\n:Return Tangent Aim Point #2;\nelse(no)\nendif\n\nstop"}
{"content":"5.\tWhen the UAV relative position to the target is less than the minimum standoff distance, NLGuidance shall command the nearest inertial position in order to reestablish the minimum standoff distance while maintaining the target on the port-side of the vehicle.","plantuml":"start\n\n:In NLGuidance;\nif(UAV relative position to target < minimum standoff distance?) then(yes)\nfork\n:Command nearest inertial position;\n:Reestablish minimum standoff distance;\nfork again\n:Maintain target on vehicle port-side;\nend fork\n\nelse(no)\nendif\n\nstop"}
{"content":"6.\tNLGuidance shall output consistent aim point with a static target without appreciable transient behavior in the command generation other than aim point switching where a transient is required to maintain a counter clockwise loiter (ref requirement 3).  Appreciable transient behavior is defined as erratic changes in the aim point command, beyond the following specific tolerance: a.\tThe change in the magnitude of the output over one frame of execution with T sample period shall not exceed the quantity of the combined velocity of the target plus the velocity of the vehicle multiplied by T.","plantuml":"start\n\n:In NLGuidance;\n:Output consistent aim point with static target;\n\nif(Transient is required to maintain counter clockwise loiter?) then(yes)\n:Aim point switching;\nelse(no)\n if(Change with T sample period > (Quantity + Velocity) * T?) then(yes)\n :Erratic changes in aim point command;\n stop\n else(no)\n endif\nendif\n\n:Output consistent aim point with static target;\n\nstop"}
{"content":"7.\tNLGuidance shall output the equivalent altitude of the vehicle for in-plane navigation.  In-plane navigation is defined where the target and the vehicle altitude (3rd component in the input inertial position vectors) are equal.","plantuml":"start\n\n:In NLGuidance;\nif(target = vehicle altitude?) then(yes)\n:Define In-plane navigation;\n:Output equivalent altitude of the vehicle;\nelse(no)\nendif\n\nstop"}
{"content":"1.\tThe maximum value of the NN output, z, shall always be less than or equal to 1.1, regardless of the input values.","plantuml":"start\n\n:Input any value;\nif(Maximum value of NN output z <= 1.1?) then(yes)\n:Allowed;\nelse(no)\n:Not allowed;\nendif\n\nstop"}
{"content":"2.\tThe minimum value of the NN output, z, shall always be greater than or equal to -0.2, regardless of the input values.","plantuml":"start\n\n:Input any value;\nif(Minimum value of NN output z >= -0.2?) then(yes)\n:Allowed;\nelse(no)\n:Not allowed;\nendif\n\nstop"}
{"content":"3.\tUsing a first order finite backward difference equation, the spatial derivatives of Δz/ Δxt = (z(n,1)-z(n-1))/(xt(n,1)-xt(n-1,1) and Δz/ Δyt = (z(n,1)-z(n-1))/(yt(n,1)-yt(n-1,1) shall never exceed a top bound of +10 or bottom bound of -35 (e.g. -35 <= Δz/ Δ(xt,yt) <= 10), where n denotes an index to the current values and n-1 denotes the prior values in the included truth data for xt and yt.","plantuml":"start\n\n:Use first order finite backward difference equation;\nfork\n:n:index to current values;\nfork again\n:n-1:prior values;\nfork again\n:Included truth data for xt and yt;\nend fork\n\nfork\n: Δz/ Δxt = (z(n,1)-z(n-1))/(xt(n,1)-xt(n-1,1));\nfork again\n:Δz/ Δyt = (z(n,1)-z(n-1))/(yt(n,1)-yt(n-1,1));\nend fork\n\nif(-35 <= Spatial derivatives <= 10?) then(yes)\n:Allowed;\nelse(no)\n:Not allowed;\nendif\n\nstop"}
{"content":"4.\tThe absolute error between the zt truth data and the output z shall never exceed a tolerance of 0.01, for the equivalent input of (xt, yt).","plantuml":"start\n\n:For equivalent input of (xt, yt);\n\nif(absolute error between zt truth data and output z <= 0.01?) then(yes)\n:Allowed;\nelse(no)\n:Not allowed;\nendif\n\nstop"}
{"content":"1.\tWhen the determinant of B(inv(Wp’)B’ is <= 1e-12 as indicated by ridge_on set to True, the inversion of the B(inv(Wp’)B’ matrix should be accurate to 6 digits precision in that each element in the check output matrix is within a 1e-6 tolerance with respect to the elements of a 3x3 identity matrix.","plantuml":"start\n\n:Ridge_on set to True;\n:Determinant of B(inv(Wp’)B’<= 1e-12;\n:Each element with respect to 3x3 identity matrix elements < 1e-6 tolerance;\n:B(inv(Wp’)B’matrix inversion be accurate to 6 digits precision;\n\nstop"}
{"content":"2.\tWhen the determinant of B(inv(Wp’)B’ is > 1e-12 as indicated by ridge_on set to False, the inversion of the B(inv(Wp’)B’ matrix should be accurate to 12 digits precision in that each element in the check output matrix is within a 1e-12 tolerance with respect to the elements of a 3x3 identity matrix.","plantuml":"start\n\n:Ridge_on set to False;\n:Determinant of B(inv(Wp’)B’> 1e-12;\n:Each element with respect to 3x3 identity matrix elements < 1e-12 tolerance;\n:B(inv(Wp’)B’matrix inversion be accurate to 12 digits precision;\n\nstop"}
{"content":"3.\tThe output u vector should be a 5x1 vector.","plantuml":"start\n\n:Output u vector;\nif(5x1 vector?) then(yes)\n:Allowed;\nelse(no)\n:Not allowed;\nendif\n\nstop"}
{"content":"4.\tThe 2-norm of the output Buminusd should be less than 0.01.","plantuml":"start\n\n:2-norm of output Buminusd;\nif(< 0.01? ) then(yes)\n:Allowed;\nelse(no)\n:Not allowed;\nendif\n\nstop"}
{"content":"5.\tThe output cost J shall be the minimum possible value given the set of input conditions.","plantuml":"start\n\n:Output cost J;\nif(Minimum possible value?) then(yes)\n:Allowed;\nelse(no)\n:Not allowed;\nendif\n\nstop"}
{"content":"Roll Autopilot shall engage when the pilot selects the autopilot engage switch in the cockpit and disengage when the switch is deselected. When not engaged, the command to the roll actuator shall be zero.","plantuml":"start\n\n:In cockpit;\nswitch(Autopilot engage switch)\ncase(Select)\n:Roll Autopilot engage;\ncase(Deselect)\n:Roll Autopilot disengage;\n:Command to roll actuator be zero;\nendswitch\n\nstop"}
{"content":"Roll hold mode shall be the active mode whenever the autopilot is engaged and no other lateral mode is active.","plantuml":"start\n\nif(Autopilot is engaged?) then (yes) \n if(No other lateral mode is active?) then(yes)\n :Roll hold mode be active mode;\n else(no)\n endif\nelse(no)\nendif\n\nstop"}
{"content":"When roll hold mode becomes the active mode the roll hold reference shall be set to the actual roll attitude of the aircraft, except under the following conditions: The roll hold reference shall be set to zero if the actual roll angle is less than 6 degrees, in either direction, at the time of roll hold engagement. The roll hold reference shall be set to 30 degrees in the same direction as the actual roll angle if the actual roll angle is greater than 30 degrees at the time of roll hold engagement. The roll reference shall be set to the cockpit turn knob command, up to a 30 degree limit, if the turn knob is commanding 3 degrees or more in either direction.","plantuml":"start\n\n:Roll hold mode becomes the active mode;\nif(Actual roll angle < 6 degrees?) then(yes)\n:Roll hold reference = zero;\nelse(no)\n:Roll hold reference = Actual roll attitude;\nendif\n\nif(Actual roll angle > 30 degrees?) then(yes)\nfork\n:Roll hold reference = 30 degrees;\nfork again\n:In same direction as actual roll angle;\nend fork\nelse(no)\nendif\n\nif(Turn knob commands 3 degrees or more in either direction?) then(yes)\n:Roll reference be set to command;\n:Up to 30 degree limit;\nelse(no)\nendif\n\nstop"}
{"content":"Heading Hold shall become the active mode when the pilot selects the heading switch in the cockpit and deactivate when the switch is deselected.","plantuml":"start\n\n:In the cockpit;\nswitch(Select heading switch)\ncase(Select)\n:Heading Hold becomes active mode;\ncase(Deselect)\n:Active mode deactivates;\nendswitch\n\nstop"}
{"content":"Requirement\tWhen heading hold mode becomes the active mode the heading hold reference shall be set by the pilot via a cockpit control.","plantuml":"start\n\n:Requirement When heading hold mode becomes active;\n:Pilot uses cockpit control;\n:Set heading hold reference;\n\nstop"}
{"content":"1.\tThe Rotation Matrix Output, DCM321, of this Function Shall Equal a 3x3 Matrix Product of a 3x3 Euler 3 (Roll) Rotation Matrix times a 3x3 Euler 2 (Pitch) Rotation Matrix times a 3x3 Euler 1 (Heading) Rotation Matrix.","plantuml":"start\n\n:Rotation Matrix Output DCM321;\nif( =Roll * Pitch * Heading 3*3 Matrix Product?) then(yes)\n:Allowed;\nelse(no)\n:Not allowed;\nendif\n\nstop"}
{"content":"2.\tThe Body Vector Output, Vb, of this Function Shall Equal a 3x1 Vector Product of the 3x3 Rotation Matrix Output, DCM321, times the Input Inertial Vector, Vi.","plantuml":"start\n\n:Body Vector Output Vb;\nif( =DCM321 * Vi?) then(yes)\n:Allowed;\nelse(no)\n:Not allowed;\nendif\n\nstop"}
{"content":"3.\tThe magnitude of the Body Vector Output, Vb, shall equal the magnitude of the Input Inertial Vector, Vi.","plantuml":"start\n\n:Magnitude of Vb;\nif( =Magnitude of Vi?) then(yes)\n:Allowed;\nelse(no)\n:Not allowed;\nendif\n\nstop"}
{"content":"4.\tThe Rotation Matrix, DCM321, shall be invertible with the exception of the case where theta = +/- pi/2 radians.","plantuml":"start\n\n:Rotation Matrix DCM321;\nif(theta = +/- pi/2 radians?) then(yes)\n:Not invertible;\nelse(no)\n:Invertible;\nendif\n\nstop"}
{"content":"5.\tThe Rotation Matrix, DCM321, shall provide a distinct mapping from the input vector, Vi, to the output vector, Vb, for each pitch angle, theta.  Note:  the DCM321 is not distinct for all phi and psi inputs.","plantuml":"start\n\n:For each pitch angle, theta;\n:DCM321 provides distinct mapping from Vi to Vb;\n:DCM321 is not distinct for all phi and psi inputs;\n\nstop"}
{"content":"6.\tThe rows and columns of the Rotation Matrix, DCM321, shall be orthonormal.  For instance, denoting r1 as row 1 and r2 as row 2 of DCM321, <r1, r2> = r1 r2T = 0 and <r1, r1> = r1 r1T = 1.  Likewise, with c1 as column 1 and c2 as column 2 of DCM321, <c1, c2> = c1 c2T = 0 and <c1, c1> = c1 c1T = 1.","plantuml":"start\n\n:Rows and columns of DCM321;\nif(Orthonormal?) then(yes)\n:Allowed;\n\nfork\n:<r1, r2> = r1 r2T = 0;\nfork again\n:<r1, r1> = r1 r1T = 1;\nend fork\n\nfork\n:<c1, c2> = c1 c2T = 0;\nfork again\n:<c1, c1> = c1 c1T = 1;\nend fork\n\nelse(no)\n:Not allowed;\nendif\n\nstop"}
{"content":"7.\tThe Rotation Matrix, DCM321, multiplied by the transpose of the Rotation Matrix, DCM321T shall be the Identity (3x3) Matrix.v","plantuml":"start\n\n:DCM321 * DCM321T;\nif( =Identity (3x3) Matrix.v?) then(yes)\n:Allowed;\nelse(no)\n:Not allowed;\nendif\n\nstop"}
{"content":"8.\tThe determinant of the Rotation Matrix, |DCM321|, shall be equal to 1.0.","plantuml":"start\n\n:Determinant of Rotation Matrix |DCM321|;\nif( =10?) then(yes)\n:Allowed;\nelse(no)\n:Not allowed;\nendif\n\nstop"}
